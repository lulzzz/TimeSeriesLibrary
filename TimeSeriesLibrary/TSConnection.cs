using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Text;

namespace TimeSeriesLibrary
{
    /// <summary>
    /// This class contains a System.Data.SqlClient.SqlConnection object for a single database
    /// connection, along with objects that are specific to that connection.
    /// </summary>
    public class TSConnection
    {

        #region Public properties
        /// <summary>
        /// SqlConnection object
        /// </summary>
        public SqlConnection Connection { get; set; }

        // As of 2018 Jan 02, there are no more uses of field 'PreparedSqlCommands'.  Please refer to
        // git commits earlier than that date to see examples of this field in use.

        ///// <summary>
        ///// Collection of wrapper objects for SqlCommand objects that have been cached using
        ///// the SqlCommand.Prepare method.
        ///// </summary>
        //public List<TSSqlCommandContainer> PreparedSqlCommands = new List<TSSqlCommandContainer>();

        /// <summary>
        /// Dictionary of DataTable objects that are used for SqlBulkCopy operations.
        /// The Dictionary key is the name of the table that is to be written to.
        /// </summary>
        public Dictionary<String, DataTable> BulkCopyDataTables = new Dictionary<String, DataTable>();
        #endregion

        #region Constructor
        /// <summary>
        /// Constructor
        /// </summary>
        /// <param name="connection">SqlConnection object to be contained
        /// by the new TSConnection object</param>
        public TSConnection(SqlConnection connection)
        {
            Connection = connection;
        } 
        #endregion

        #region 'Commit' methods
        /// <summary>
        /// This method writes the data in the DataTable object to the database table with the given
        /// name.  This method is designed to be called after making several calls to method 
        /// TS.WriteTrace, which adds data to the DataTable object.  The given table name is used as
        /// a key to find the DataTable object in this TSConnection object's BulkCopyDataTables
        /// dictionary.  If the DataTable object is not found in the dictionary, then this method
        /// simply does nothing.  After this method writes the data in the DataTable object to the
        /// database, it disposes the DataTable object.
        /// </summary>
        /// <param name="tableName">The name of the database table that is used as a key to look up
        /// the DataTable object. If the 'targetTableName' parameter is null, then this is also the
        /// name of the database table to which the DataTable's data is stored.</param>
        /// <param name="targetTableName">The name of the database table to which the DataTable's data
        /// is to be stored.  If this parameter is null, then the 'tableName' parameter's value is used.
        /// The default is null.</param>
        public void CommitWritesToTable(String tableName, String targetTableName = null)
        {
            // Get the DataTable object from the Dictionary
            DataTable dataTable;
            if (BulkCopyDataTables.TryGetValue(tableName, out dataTable) == false)
            {
                // If the DataTable object was not found in the dictionary,
                // then this method does nothing.
                return;
            }
            SqlBulkCopy copier = null;
            try
            {
                // Instantiate a SqlBulkCopy object
                copier = new SqlBulkCopy(Connection, SqlBulkCopyOptions.TableLock, null)
                {
                    BulkCopyTimeout = 0,
                    BatchSize = 0,
                    EnableStreaming = true,
                    DestinationTableName = targetTableName ?? tableName
                };
                // The DataTable is presumed to lack any column corresponding to an IDENTITY column
                // of the database table (i.e., a column whose value is autogenerated by the server).
                // Because it is presumed that the DataTable and database do not have the same number
                // of columns, the SqlBulkCopy object can not automatically map the columns of the
                // DataTable to the columns of the database table.  Therefore, we must explicitly
                // create the ColumnMappings now.  This is simple, because the columns in the DataTable
                // should have the same names as the columns in the database table.
                foreach (DataColumn column in dataTable.Columns)
                    copier.ColumnMappings.Add(column.ColumnName, column.ColumnName);
                // Insert the data into the database table.
                copier.WriteToServer(dataTable);
            }
            finally
            {
                // Dispose the SqlBulkCopy object.
                if (copier != null)
                    ((IDisposable)copier).Dispose();
                // Dispose the DataTable object.
                dataTable.Dispose();
                // Remove the DataTable object from the dictionary.
                BulkCopyDataTables.Remove(tableName);
            }
        }
        /// <summary>
        /// This method writes the data in the DataTable objects to the database tables with the given
        /// names.  This method is designed to be called after making several calls to method 
        /// TS.WriteTrace, which adds data to the DataTable objects.  The given table names are used as
        /// keys to find the DataTable objects in this TSConnection object's BulkCopyDataTables
        /// dictionary.  If the DataTable objects are not found in the dictionary, then this method
        /// simply does nothing.  After this method writes the data in the DataTable objects to the
        /// database, it disposes the DataTable objects.
        /// </summary>
        /// <param name="traceTableName">the name of the trace table where data is to be written</param>
        /// <param name="parametersTableName">the name of the trace table where data
        /// is to be written</param>
        public void CommitNewTraceWrites(String parametersTableName, String traceTableName)
        {
            // Use SqlBulkCopy to very quickly copy the new values for the traces table to database
            CommitWritesToTable(traceTableName);
            // It seems unclear to me what should be done if the above method fails--it is
            // an unlikely scenario in any case.

            // Drop the temporary table if it somehow already exists
            String tempTableName = "#" + parametersTableName
                        + "_" + Guid.NewGuid().ToString("N").Substring(0, 16);
            String dropCommandText
                    = String.Format("IF OBJECT_ID('tempdb..{0}','U') IS NOT NULL DROP TABLE {0};",
                                        tempTableName);
            using (var dropTableCommand = new SqlCommand(dropCommandText, Connection))
            {
                dropTableCommand.ExecuteNonQuery();
            }
            // Create a temporary table that will be used to store changes to the Checksum column
            // of the parameters table before they are MERGEd back into the real table.
            String commandText = String.Format("CREATE TABLE {0}\n(\n"
                            + "  [Id] [int] NOT NULL,\n"
                            + "  [Checksum] [binary](16) NOT NULL\n)\n", tempTableName);
            using (var createTableCommand = new SqlCommand(commandText, Connection))
            {
                createTableCommand.ExecuteNonQuery();
            }
            // Use SqlBulkCopy to very quickly copy the new values for the parameters table to the
            // temporary table in the database
            CommitWritesToTable(parametersTableName, tempTableName);
            // Move the corrected values from the temporary table to the real parameters table
            commandText = String.Format("MERGE INTO [{0}] c\n  USING {1} tmp ON c.[Id] = tmp.[Id]\n"
                    + "  WHEN MATCHED THEN UPDATE SET [Checksum] = tmp.[Checksum];",
                    parametersTableName, tempTableName);
            using (var mergeCommand = new SqlCommand(commandText, Connection))
            {
                mergeCommand.CommandTimeout = 0;
                mergeCommand.ExecuteNonQuery();
            }
            // Drop the temporary table
            using (var dropTableCommand = new SqlCommand(dropCommandText, Connection))
            {
                dropTableCommand.ExecuteNonQuery();
            }

        } 
        #endregion

    }
}
